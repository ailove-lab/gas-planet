// Generated by CoffeeScript 2.3.1
var RTT, animate, background, camera, clock, container, ctx, current_material, cvs, draw_spot, frag_fbm_01, frag_screen, generate_planet_texture, init, init_gui, init_materilas, init_planet_texture, init_renderers, init_scene, input, light_1, light_2, light_3, light_mat, material, materials, materials_cnt, onLoad, onWindowResize, p2u, params, planet, planet_details, planet_radius, planet_resolution, pr_h, pr_w, render, renderer, rnd, rtt, scene, seed, shader_load, shadows_mat, stats, text_load, time, velocities, vert_simple;

onWindowResize = function(event) {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  return renderer.setSize(window.innerWidth, window.innerHeight);
};

onLoad = function() {
  init();
  init_gui();
  return animate();
};

input = function(val) {
  var current_material, hash, seed;
  hash = Math.abs(val.hashCode());
  seed = hash;
  current_material = materials[hash % materials_cnt];
  current_material.uniforms.id.value = hash;
  generate_planet_texture();
  velocities.value.needsUpdate = true;
  return planet.material = current_material;
};

window.addEventListener("resize", onWindowResize, false);

window.addEventListener("load", onLoad);

params = {
  background: false,
  u_col1: [256 * 0.2 | 0, 256 * 0.1 | 0, 256 * 0.4 | 0],
  u_col2: [256 * 0.3 | 0, 256 * 0.05 | 0, 256 * 0.05 | 0],
  u_col3: [256 * 0.9 | 0, 256 * 0.9 | 0, 256 * 0.9 | 0],
  u_col4: [256 * 0.5 | 0, 256 * 0.2 | 0, 256 * 0.2 | 0],
  u_col5: [256 * 0.0 | 0, 256 * 0.2 | 0, 256 * 0.4 | 0],
  u_col6: [256 * 0.85 | 0, 256 * 0.90 | 0, 256 * 0.95 | 0],
  u_col7: [256 * 0.15 | 0, 256 * 0.10 | 0, 256 * 0.05 | 0],
  u_col8: [256 * 0.85 | 0, 256 * 0.90 | 0, 256 * 0.95 | 0],
  u_col9: [256 * 0.15 | 0, 256 * 0.10 | 0, 256 * 0.05 | 0],
  u_scale: 4.0,
  u_speed: 1.0
};

p2u = function(p) {
  return new THREE.Vector3(params[p][0] / 255.0, params[p][1] / 255.0, params[p][2] / 255.0);
};

init_gui = function() {
  var c, color_changer, gui, i, j, k, l, len, light_mat_data, lights_data, n, ref, results, shadows_mat_data, t, u_col;
  color_changer = function(c) {
    return function(v) {
      return c.set(v);
    };
  };
  gui = new dat.GUI;
  gui.add(params, 'background').onChange(function() {
    return background.visible = params.background;
  });
  gui.add(params, 'u_scale', 0.1, 20.0, 0.1).onChange(function(v) {
    return material.uniforms.u_scale.value = v;
  });
  gui.add(params, 'u_speed', 0.1, 20.0, 0.1).onChange(function(v) {
    return material.uniforms.u_speed.value = v;
  });
  u_col = function(name) {
    return function(val) {
      return material.uniforms[name].value = p2u(name);
    };
  };
  for (c = j = 1; j <= 9; c = ++j) {
    gui.addColor(params, `u_col${c}`).onChange(u_col(`u_col${c}`));
  }
  t = gui.addFolder("Shadow mat");
  shadows_mat_data = {
    color: shadows_mat.color.getHex()
  };
  t.addColor(shadows_mat_data, "color").onChange(color_changer(shadows_mat.color));
  t.add(shadows_mat, "metalness", 0.0, 1.0, 0.1); // : 0.0
  t.add(shadows_mat, "roughness", 0.0, 1.0, 0.1); // : 1.0
  t.add(shadows_mat, "opacity", 0.0, 1.0, 0.1); // : 0.61
  t.add(shadows_mat, "transparent"); // : true
  t.add(shadows_mat, "premultipliedAlpha"); // : true
  t = gui.addFolder("Light mat");
  light_mat_data = {
    color: light_mat.color.getHex()
  };
  t.addColor(light_mat_data, "color").onChange(color_changer(light_mat.color));
  t.add(light_mat, "metalness", 0.0, 1.0, 0.1); // : 0.0
  t.add(light_mat, "roughness", 0.0, 1.0, 0.1); // : 1.0
  t.add(light_mat, "opacity", 0.0, 1.0, 0.1); // : 0.61
  t.add(light_mat, "transparent"); // : true
  t.add(light_mat, "premultipliedAlpha"); // : true
  lights_data = {};
  ref = [1, 2, 3].map(function(i) {
    return this[`light_${i}`];
  });
  results = [];
  for (i = k = 0, len = ref.length; k < len; i = ++k) {
    l = ref[i];
    n = `${l.type} ${i}`;
    t = gui.addFolder(n);
    t.add(l, "intensity", 0.0, 10.0, 0.1);
    lights_data[n] = {
      color: l.color.getHex()
    };
    results.push(t.addColor(lights_data[n], "color").onChange(color_changer(l.color)));
  }
  return results;
};

container = void 0;

stats = void 0;

camera = void 0;

scene = void 0;

renderer = void 0;

clock = void 0;

planet = void 0;

background = void 0;

rtt = void 0;

material = void 0;

shadows_mat = void 0;

light_mat = void 0;

light_1 = void 0;

light_2 = void 0;

light_3 = void 0;

planet_radius = 1.2;

planet_details = 50;

planet_resolution = 256;

pr_w = planet_resolution;

pr_h = planet_resolution;

cvs = void 0;

ctx = void 0;

velocities = void 0;

materials = [];

materials_cnt = 8;

current_material = void 0;

time = {
  value: 1.0
};

seed = 1;

init_materilas = function(vert, frag) {};

animate = function() {
  requestAnimationFrame(animate);
  render();
  return stats.update();
};

render = function() {
  var delta;
  delta = clock.getDelta();
  material.uniforms.u_time.value = clock.elapsedTime;
  // renderer.setPixelRatio( 1 );
  // renderer.setSize( 256,256 );
  // renderer.autoClear = false;
  // renderer.render rtt.scene, rtt.camera, rtt.texture
  // rtt.render(renderer)

  // if planet?
  //     planet.rotation.y += delta * 0.25

  // renderer.setPixelRatio( window.devicePixelRatio );
  // renderer.setSize( window.innerWidth, window.innerHeight );
  // renderer.autoClear = false;
  return renderer.render(scene, camera);
};

init_renderers = function() {
  renderer = new THREE.WebGLRenderer({
    alpha: true,
    autoClear: false
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  // rtt = new RTT
  container = document.getElementById('container');
  return container.appendChild(renderer.domElement);
};

init_scene = function() {
  var c, g, j, light, noise, shadows, uniforms;
  camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 3000);
  camera.position.z = 4;
  scene = new THREE.Scene;
  clock = new THREE.Clock;
  noise = new THREE.TextureLoader().load('textures/noise_256.png');
  //noise.wrapS = noise.wrapT = THREE.RepeatWrapping
  uniforms = {
    u_bufA: {
      type: 't',
      value: noise
    },
    u_time: {
      type: 'f',
      value: 0.0
    },
    u_scale: {
      type: 'f',
      value: 4.0
    },
    u_speed: {
      type: 'f',
      value: 1.0
    }
  };
  for (c = j = 1; j <= 9; c = ++j) {
    uniforms[`u_col${c}`] = {
      type: 'v3',
      value: p2u(`u_col${c}`)
    };
  }
  material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vert_simple,
    fragmentShader: frag_fbm_01,
    extensions: {
      shaderTextureLOD: true // set to use shader texture LOD
    }
  });
  g = new THREE.PlaneBufferGeometry(5, 2.5, 10);
  background = new THREE.Mesh(g, material);
  background.visible = params.background;
  scene.add(background);
  g = new THREE.SphereBufferGeometry(planet_radius, planet_details, planet_details);
  planet = new THREE.Mesh(g, material);
  planet.rotation.x = 3.141 / 8.0;
  scene.add(planet);
  g = new THREE.SphereBufferGeometry(planet_radius * 1.001, planet_details, planet_details);
  shadows_mat = new THREE.MeshPhysicalMaterial({
    map: null,
    color: 0xFFFFFF,
    metalness: 0.0,
    roughness: 1.0,
    opacity: 1.0,
    side: THREE.FrontSide,
    transparent: true,
    premultipliedAlpha: true,
    depthTest: false,
    blending: THREE.MultiplyBlending
  });
  shadows = new THREE.Mesh(g, shadows_mat);
  scene.add(shadows);
  light_mat = new THREE.MeshPhysicalMaterial({
    color: 0x202020,
    metalness: 0.5,
    roughness: 0.6,
    opacity: 0.5,
    side: THREE.FrontSide,
    transparent: true,
    premultipliedAlpha: true,
    depthTest: false,
    blending: THREE.AdditiveBlending
  });
  light = new THREE.Mesh(g, light_mat);
  scene.add(light);
  light_1 = new THREE.PointLight(0xffffD0, 2);
  light_1.position.set(-50, 50, 50);
  scene.add(light_1);
  light_2 = new THREE.PointLight(0x404080, 2);
  light_2.position.set(50, -50, -50);
  scene.add(light_2);
  light_3 = new THREE.PointLight(0x808040, 0.5);
  light_3.position.set(0, -100, 0);
  return scene.add(light_3);
};

init = function() {
  console.log("Init");
  if (!Detector.webgl) {
    Detector.addGetWebGLMessage();
  }
  init_renderers();
  init_scene();
  stats = new Stats;
  container.appendChild(stats.dom);
  return onWindowResize();
};

RTT = class RTT {
  constructor() {
    
    // g = new THREE.SphereBufferGeometry 0.1
    // s = new THREE.Mesh g, new THREE.MeshBasicMaterial({color: 0x808080})
    // @scene.add s

    // @renderer = new THREE.WebGLRenderer
    // @renderer.setSize(@resolution, @resolution);
    // @renderer.setPixelRatio 1.0
    // @renderer.autoClear = false
    this.render = this.render.bind(this);
    this.resolution = 1024;
    this.iteration = 0;
    this.camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
    this.camera.position.z = 100;
    this.scene = new THREE.Scene;
    this.textureA = new THREE.WebGLRenderTarget(this.resolution, this.resolution, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat
    });
    this.textureB = new THREE.WebGLRenderTarget(this.resolution, this.resolution, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      format: THREE.RGBAFormat
    });
    this.bufB = new THREE.TextureLoader().load("textures/jupiter_1024_n.png");
    this.bufB.wrapS = this.bufB.wrapT = THREE.RepeatWrapping;
    this.bufC = new THREE.TextureLoader().load("textures/jupiter_1024.png");
    this.bufC.wrapS = this.bufC.wrapT = THREE.RepeatWrapping;
    this.mat = new THREE.ShaderMaterial({
      uniforms: {
        bufA: {
          type: 't',
          value: this.textureA
        },
        bufB: {
          type: 't',
          value: this.bufB
        },
        bufC: {
          type: 't',
          value: this.bufC
        },
        time: {
          type: 'f',
          value: 0.0
        }
      },
      vertexShader: vert_simple,
      fragmentShader: frag_fbm_05,
      depthWrite: false
    });
    this.mat_screen = new THREE.ShaderMaterial({
      uniforms: {
        texture: {
          type: "t",
          value: this.textureA
        }
      },
      vertexShader: vert_simple,
      fragmentShader: frag_screen
    });
    this.plane = new THREE.PlaneBufferGeometry(1.0, 1.0);
    this.quad = new THREE.Mesh(this.plane, this.mat);
    this.quad.position.z = -100;
    this.scene.add(this.quad);
  }

  render(renderer) {
    this.mat.uniforms.time.value += 0.1;
    renderer.preserveDrawingBuffer = true;
    renderer.autoClear = false;
    renderer.setPixelRatio(1);
    renderer.setSize(this.resolution, this.resolution);
    if (this.iteration % 2 === 0) {
      this.mat.uniforms.bufA.value = this.textureB.texture;
      this.render_target = this.textureA;
    } else {
      this.mat.uniforms.bufA.value = this.textureA.texture;
      this.render_target = this.textureB;
    }
    renderer.render(this.scene, this.camera, this.render_target, false);
    return this.iteration++;
  }

};

// ../shaders/simple.vert
vert_simple = "varying vec2 vUv;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvoid main() {\n    vUv = uv;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position     = projectionMatrix * mvPosition; \n    gl_Position     = projectionMatrix * mvPosition;\n    vPos            = vec3(mvPosition)/mvPosition.w;\n    vNormal         = vec3(normalMatrix * normal);\n}";

// ../shaders/screen.frag
frag_screen = "varying vec2 vUv;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nuniform sampler2D texture;\nvoid main() {\n    gl_FragColor = texture2D(texture, vUv)*vNormal.z*vNormal.z;\n    gl_FragColor.a = 1.0;\n}";

// ../shaders/fbm_01.frag
frag_fbm_01 = "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See http://www.iquilezles.org/www/articles/warp/warp.htm for details\n\n// undefine these on old/slow computers\n#define SLOW_NOISE\n#define SLOW_NORMAL\n\nvarying vec2 vUv;\n\nuniform sampler2D u_bufA;\n\nuniform vec2 u_mouse;\nuniform float u_time;\nuniform float u_scale;\nuniform float u_speed;\n\nuniform vec3 u_col1;\nuniform vec3 u_col2;\nuniform vec3 u_col3;\nuniform vec3 u_col4;\nuniform vec3 u_col5;\nuniform vec3 u_col6;\nuniform vec3 u_col7;\nuniform vec3 u_col8;\nuniform vec3 u_col9;\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,31.1459123));\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n#ifdef SLOW_NOISE\n    float a = texture2DLodEXT(u_bufA,(p+vec2(0.5,0.5))/256.0,0.0).x;\n	float b = texture2DLodEXT(u_bufA,(p+vec2(1.5,0.5))/256.0,0.0).x;\n	float c = texture2DLodEXT(u_bufA,(p+vec2(0.5,1.5))/256.0,0.0).x;\n	float d = texture2DLodEXT(u_bufA,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n#else\n	return texture2DLodEXT( u_bufA, (p+0.5+f)/256.0, 0. ).x;\n#endif    \n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.2500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1250*(-1.0+2.0*noise( p )); p = mtx*p*2.01;\n    f += 0.0625*(-1.0+2.0*noise( p ));\n\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n\n    return f/0.96875;\n}\n\nfloat func( vec2 q, out vec2 o, out vec2 n )\n{\n    float ql = length( q );\n    q.x += 0.05*sin(0.11*u_time*u_speed+ql*4.0);\n    q.y += 0.05*sin(0.13*u_time*u_speed+ql*4.0);\n\n    q *= 0.7 + 0.2*cos(0.05*u_time);\n\n    q = (q+1.0)*0.5;\n\n    o.x = 0.5 + 0.5*fbm4( vec2(2.0*q*vec2(1.0,1.0)          )  );\n    o.y = 0.5 + 0.5*fbm4( vec2(2.0*q*vec2(1.0,1.0)+vec2(5.2))  );\n\n    float ol = length( o );\n    o.x += 0.02*sin(0.11*u_time*u_speed*ol)/ol;\n    o.y += 0.02*sin(0.13*u_time*u_speed*ol)/ol;\n\n\n    n.x = fbm6( vec2(4.0*o*vec2(1.0,1.0)+vec2(9.2))  );\n    n.y = fbm6( vec2(4.0*o*vec2(1.0,1.0)+vec2(5.7))  );\n\n    vec2 p = 4.0*q + 4.0*n;\n\n    float f = 0.5 + 0.5*fbm4( p );\n\n    f = mix( f, f*f*f*3.5, f*abs(n.x) );\n\n    float g = 0.5+0.5*sin(4.0*p.x)*sin(4.0*p.y);\n    f *= 1.0-0.5*pow( g, 8.0 );\n\n    return f;\n}\n\nfloat funcs( in vec2 q )\n{\n    vec2 t1, t2;\n    return func(q,t1,t2);\n}\n\n\nvoid main() {\n    vec2 resolution = vec2(1024.0);\n    vec2 of = vec2(0.0);//hash2( float(u_time)*1113.1 + gl_FragCoord.x + gl_FragCoord.y*119.1 );\n    \n	vec2 p = vUv;// gl_FragCoord / resolution.xy;\n	vec2 q = (p*2.0-vec2(1.0))*u_scale;// (-resolution.xy + 2.0*(gl_FragCoord+of)) /resolution.y;\n    q.x-=u_time*0.2;	\n    vec2 o, n;\n    float f = func(q, o, n);\n    vec3 col = vec3(0.0);\n\n\n    col = mix( u_col1, u_col2, f );\n    col = mix( col, u_col3, dot(n,n) );\n    col = mix( col, u_col4, 0.5*o.y*o.y );\n\n    col = mix( col, u_col5, 0.5*smoothstep(1.2,1.3,abs(n.y)+abs(n.x)) );\n\n    col *= f*2.0;\n    \n#ifdef SLOW_NORMAL\n    vec2 ex = vec2( 1.0 / resolution.x, 0.0 );\n    vec2 ey = vec2( 0.0, 1.0 / resolution.y );\n	vec3 nor = normalize( vec3( funcs(q+ex) - f, ex.x, funcs(q+ey) - f ) );\n#else\n    vec3 nor = normalize( vec3( dFdx(f)*resolution.x, 1.7, dFdy(f)*resolution.y ) );	\n#endif\n    vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n\n    vec3 bdrf;\n    bdrf  = u_col6*(nor.y*0.5+0.5);\n    bdrf += u_col7*dif;\n    bdrf  = u_col8*(nor.y*0.5+0.5);\n    bdrf += u_col9*dif;\n\n    col *= bdrf;\n\n    col = vec3(1.0)-col;\n\n    col = col*col;\n\n    col *= vec3(1.2,1.25,1.2);\n	\n	col *= 0.5 + 0.5 * sqrt(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y));\n	\n	gl_FragColor = vec4( col, 1.0 );\n}";

rnd = function(r) {
  var x;
  x = Math.sin(seed++) * 10000;
  return (x - Math.floor(x)) * r;
};

p2u = function(p) {
  return new THREE.Vector3(params[p][0] / 255.0, params[p][1] / 255.0, params[p][2] / 255.0);
};

text_load = function(url) {
  return new Promise(function(resolve, reject) {
    var loader;
    loader = new THREE.XHRLoader(THREE.DefaultLoadingManager);
    loader.setResponseType('text');
    return loader.load(url, resolve, null, reject);
  });
};

shader_load = function(name) {
  console.log(`Load shader ${name}`);
  return Promise.all([text_load(`shaders/${name}.vert`), text_load(`shaders/${name}.frag`)]);
};

String.prototype.hashCode = function() {
  return this.split('').reduce((function(a, b) {
    a = (a << 5) - a + b.charCodeAt(0);
    return a & a;
  }), 0);
};

// Градиент скоростей
init_planet_texture = function() {
  cvs = document.createElement('canvas');
  cvs.id = 'planet_texture';
  ctx = cvs.getContext('2d');
  cvs.width = ctx.width = pr_w;
  return cvs.height = ctx.height = pr_h;
};

// document.body.prepend(cvs);
generate_planet_texture = function() {
  var i;
  var x;
  var y;
  var r;
  var c;
  var c, grd, i, r, results, x, y;
  // Основной фон
  ctx.globalCompositeOperation = 'normal';
  grd = ctx.createLinearGradient(0, 0, 0, pr_h);
  grd.addColorStop(0.0, '#000000');
  grd.addColorStop(0.5, '#202020');
  grd.addColorStop(1.0, '#000000');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, pr_w, pr_h);
  // Пятна
  i = 0;
  while (i < 100) {
    x = rnd(pr_w);
    y = pr_h / 2.0 - rnd(pr_h / 3.0) + rnd(pr_h / 3.0);
    r = 5 + rnd(20);
    c = 50;
    draw_spot(x, y, r, c);
    if (x + r > pr_w) {
      draw_spot(x - pr_w, y, r, c);
    }
    if (x - r < 0) {
      draw_spot(x + pr_w, y, r, c);
    }
    i++;
  }
  i = 0;
  results = [];
  while (i < 4) {
    x = rnd(pr_w);
    y = pr_h / 2.0 - rnd(pr_h / 4.0) + rnd(pr_h / 4.0);
    r = 5 + rnd(40);
    c = 255;
    draw_spot(x, y, r, c);
    if (x + r > pr_w) {
      draw_spot(x - pr_w, y, r, c);
    }
    if (x - r < 0) {
      draw_spot(x + pr_w, y, r, c);
    }
    results.push(i++);
  }
  return results;
};

draw_spot = function(x, y, r, c) {
  var grd;
  grd = ctx.createRadialGradient(x, y, 0, x, y, r);
  grd.addColorStop(0.0, `rgba(${c},${c},${c},1.0 )`);
  grd.addColorStop(0.1, `rgba(${c},${c},${c},0.8 )`);
  grd.addColorStop(0.4, `rgba(${c},${c},${c},0.2 )`);
  grd.addColorStop(0.6, `rgba(${c},${c},${c},0.01)`);
  grd.addColorStop(1.0, `rgba(${c},${c},${c},0.0 )`);
  ctx.globalCompositeOperation = 'screen';
  // Fill with gradient
  ctx.fillStyle = grd;
  return ctx.fillRect(0, 0, pr_w, pr_h);
};
